<!DOCTYPE aesl-source>
<network>


<!--list of global events-->


<!--list of constants-->
<constant value="300" name="SPEED"/>
<constant value="0" name="STOPPED"/>
<constant value="1" name="FORWARD"/>
<constant value="2" name="BLOCK"/>
<constant value="3" name="TURN"/>
<constant value="4" name="HOME"/>
<constant value="300" name="gTHRESHOLD"/>
<constant value="0" name="wTHRESHOLD"/>
<constant value="100" name="homeTHRESHOLD"/>
<constant value="150" name="lineTHRESHOLD"/>


<!--show keywords state-->
<keywords flag="true"/>


<!--node thymio-II-->
<node nodeId="1" name="thymio-II">var state = STOPPED
var myColour[3] = [0, 0, 0] #Array of values for first scan
var scanResult[3] = [2, 2, 2] #Last scan's results
var dummy
var foundColour = 0 #Turns 1 if found

#LED Colours
var LED[12] = [
	[32, 0, 0], #RED
	[0, 32, 0], #BLUE
	[0, 0, 32], #GREEN
	[0, 0, 0] #WHITE
]

var LEDCodes[12] = [
	[0, 1, 0], #RED
	[1, 1, 0], #GREEN
	[1, 0, 1], #BLUE
	[0, 0, 1] #WHITE
] 

#Location Key Quad
var locations[32] = [
	[0, 1, 0, 0],
	[1, 0, 0, 0],
	[0, 0, 0, 1],
	[0, 0, 1, 1],
	[0, 1, 1, 0],
	[1, 1, 0, 0],
	[1, 0, 0, 1],
	[0, 0, 1, 0]
]

var currLoc[4] = [2, 2, 2, 2] #2 is a placeholder null value.
var i = 0
var squareLoop = 0 #The overall loop for the search and rescue.
var SQUARE = 10 #For correct LED scan without location found.
var currQUAD = 10 #Current square in case of more wScans

onevent button.backward
	state = STOPPED
	motor.left.target = 0
	motor.right.target = 0
	
onevent button.right
	if myColour[0] == 0 then
		callsub wScan
		callsub colourFind
	end

onevent button.forward
	while  squareLoop &lt; 4 do
		callsub localize		
		callsub turn90
		
		motor.left.target = SPEED
		motor.right.target = SPEED
		state = FORWARD
		
		#Prox event that makes current loop state end for the next cycle.
	end
	
	while foundColour &lt; 1 do
		callsub wScan
		
		if currQUAD == 8 then
			currQUAD = 1
		else 
			currQUAD++
		end
		
		callsub colourFind
		
		if  foundColour == 0 then
			callsub turn90
			motor.left.target = SPEED
			motor.right.target = SPEED
			state = FORWARD
		
			#Prox event for next cycle.
		end
	end
	
	callsub returnHome
	
sub localize
	callsub gScan
	callsub wScan
	
	if  currLoc[3] &lt; 2 then
		#I'm so sorry for what I'm about to do
		#Enjoy my spaghetti code.
		if  currLoc[0] == 0 then
			if currLoc[1] == 1 then
				if  currLoc[2] == 1 then
					currQUAD = 5
				else
					currQUAD = 1
				end
			else
				if  currLoc[2] == 1 then
					if  currLoc[3] == 1 then
						currQUAD = 4
					else 
						currQUAD = 8
					end
				else
					currQUAD = 3
				end
			end
		else
			if  currLoc[1] == 1 then
				currQUAD = 6
			else
				if currLoc[3] == 1 then
					currQUAD = 7
				else
					currQUAD = 2
				end
			end			
		end
	end
		
sub gScan
	if gTHRESHOLD > prox.ground.delta[0] then
		currLoc[i] = 1
	else
		currLoc[i] = 0
	end

sub wScan
	#Scans the wall.

sub returnHome
	state = HOME
	callsub turn180
	state = HOME #Resets the state
	
	#See prox event for line detection for corners
	
	timer.period[0] = 3000 #Stops after 3 seconds and flashes results
	motor.left.target = SPEED
	motor.right.target = SPEED
	
sub flashResults
#Displays results.

sub turn180
	state = TURN
	motor.left.target = SPEED
	motor.right.target = -SPEED
	timer.period[0] = 1222
	
sub turn90
	state = TURN
	motor.left.target = SPEED
	motor.right.target = -SPEED
	timer.period[0] = 611
	
sub colourFind
	#Determines what colour through a loop.
	#call leds.top(0, 0, 0)
	
	#If finds right colour, set to 1 and set SQUARE to currQUAD
	#Else do nothing.
	
onevent timer0
	if  state == HOME then
		motor.left.target = 0
		motor.right.target = 0
		state = STOPPED
		callsub flashResults
	else
		state = FORWARD
		motor.left.target = SPEED
		motor.right.target = SPEED
	end
	
onevent prox
	if  state == HOME then
		if homeTHRESHOLD > prox.ground.delta[0] then
			timer.period[0] = 4000 #Resets timer so that it remains accurate. (Travel time + turn time)
			callsub turn90
			state = HOME #Resets the state
		end
	end
	
	if state == FORWARD then
		if  lineTHRESHOLD > prox.ground.delta[0] then
			squareLoop++
		end
	end</node>


</network>
